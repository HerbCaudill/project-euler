import { Sequence } from 'lib/Sequence'

// Triangular, pentagonal, and hexagonal
// =====================================
// Triangle, pentagonal, and hexagonal numbers are generated by the following
// formulae:
//
// Triangle     T[n]=n(n+1)/2   1, 3, 6, 10, 15, ...
// Pentagonal   P[n]=n(3n-1)/2  1, 5, 12, 22, 35, ...
// Hexagonal    H[n]=n(2n-1)    1, 6, 15, 28, 45, ...
//
// It can be verified that T[285] = P[165] = H[143] = 40755.
//
// Find the next triangle number that is also pentagonal and hexagonal.

const T = new Sequence(n => (n * (n + 1)) / 2)
const P = new Sequence(n => (n * (3 * n - 1)) / 2)
const H = new Sequence(n => n * (2 * n - 1))

expect(T.includes(40755)).toBe(true)
expect(P.includes(40755)).toBe(true)
expect(H.includes(40755)).toBe(true)

// BRUTE FORCE, BABY
const findTPH = (max: number) => {
  const hValues = H.valuesUpTo(max)
  const result = []
  for (const h of hValues) if (P.includes(h) && T.includes(h)) result.push(h)
  return result
}

expect(findTPH(50000)).toEqual([1, 40755])

export const solution045 = () => {
  // keep trying bigger and bigger spaces until we find one
  let max = 100000
  let solution: number | undefined
  while (solution === undefined) {
    const solutions = findTPH(max)
    // we know the first two solutions are [1, 40755]; we're looking for a third solution
    if (solutions.length > 2) solution = solutions[2]
    max *= 10
  }
  return solution
}
